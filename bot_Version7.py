# bot_Version7.pyimport osimport jsonimport asyncioimport loggingfrom typing import List, Tuple, Optionalimport discordfrom discord.ext import commandsfrom discord import app_commandsimport aiosqlitefrom aiohttp import web# =========================# CONFIG & LOGGING# =========================logging.basicConfig(level=logging.INFO)logger = logging.getLogger("cfb26-draft-bot")BOT_TOKEN = os.getenv("BOT_TOKEN", "REPLACE_ME")ADMIN_ID = int(os.getenv("ADMIN_ID", "123456789012345678"))  # replace or set envDATABASE_PATH = "draft_bot.db"TEAMS_JSON_PATH = "teams.json"# =========================# LOAD TEAMS & CONFERENCES# =========================with open(TEAMS_JSON_PATH, "r", encoding="utf-8") as f:    data = json.load(f)TEAMS = data["teams"]          # list of {"school": ..., "conference": null}CONFERENCES = data["conferences"]  # list of conference names (strings)TEAM_NAMES = {t["school"] for t in TEAMS}# =========================# DISCORD CLIENT SETUP# =========================intents = discord.Intents.default()intents.members = True  # needed for mentions resolving if usedbot = commands.Bot(command_prefix="!", intents=intents)tree = bot.tree# =========================# DATABASE INIT & HELPERS# =========================async def init_db():    async with aiosqlite.connect(DATABASE_PATH) as db:        await db.execute("""            CREATE TABLE IF NOT EXISTS drafts (                id INTEGER PRIMARY KEY AUTOINCREMENT,                current_pick_index INTEGER DEFAULT 1,                round_number INTEGER DEFAULT 1,                direction TEXT DEFAULT 'forward'            );        """)        await db.execute("""            CREATE TABLE IF NOT EXISTS participants (                id INTEGER PRIMARY KEY AUTOINCREMENT,                draft_id INTEGER NOT NULL,                user_id INTEGER NOT NULL,                pick_order INTEGER NOT NULL,                UNIQUE(draft_id, user_id)            );        """)        await db.execute("""            CREATE TABLE IF NOT EXISTS assigned_teams (                id INTEGER PRIMARY KEY AUTOINCREMENT,                draft_id INTEGER NOT NULL,                user_id INTEGER NOT NULL,                team_name TEXT NOT NULL,                conference TEXT,                UNIQUE(draft_id, team_name)            );        """)        await db.commit()    logger.info("Database initialized.")async def get_db():    if not hasattr(bot, "db"):        bot.db = await aiosqlite.connect(DATABASE_PATH)        bot.db.row_factory = aiosqlite.Row    return bot.db# ---- Draft helpers ----async def create_new_draft(db) -> int:    await db.execute("DELETE FROM drafts")    await db.execute("DELETE FROM participants")    await db.execute("DELETE FROM assigned_teams")    await db.execute("""        INSERT INTO drafts (current_pick_index, round_number, direction)        VALUES (1, 1, 'forward')    """)    await db.commit()    cur = await db.execute("SELECT id FROM drafts LIMIT 1")    row = await cur.fetchone()    return row["id"]async def get_active_draft_id(db) -> Optional[int]:    cur = await db.execute("SELECT id FROM drafts LIMIT 1")    row = await cur.fetchone()    return row["id"] if row else Noneasync def save_preassigned_team(db, draft_id: int, user_id: int, team_name: str):    await db.execute("""        INSERT INTO assigned_teams (draft_id, user_id, team_name, conference)        VALUES (?, ?, ?, NULL)    """, (draft_id, user_id, team_name))async def save_draft_order(db, draft_id: int, ordered_user_ids: List[int]):    await db.execute("DELETE FROM participants WHERE draft_id = ?", (draft_id,))    for index, user_id in enumerate(ordered_user_ids, start=1):        await db.execute("""            INSERT INTO participants (draft_id, user_id, pick_order)            VALUES (?, ?, ?)        """, (draft_id, user_id, index))async def get_current_pick_user(db, draft_id: int) -> Optional[int]:    cur = await db.execute("""        SELECT p.user_id        FROM participants p        JOIN drafts d ON d.current_pick_index = p.pick_order        WHERE p.draft_id = ?    """, (draft_id,))    row = await cur.fetchone()    return row["user_id"] if row else Noneasync def get_draft_state(db, draft_id: int) -> Optional[Tuple[int, int, str]]:    cur = await db.execute("""        SELECT current_pick_index, round_number, direction        FROM drafts        WHERE id = ?    """, (draft_id,))    row = await cur.fetchone()    if not row:        return None    return row["current_pick_index"], row["round_number"], row["direction"]async def set_draft_state(db, draft_id: int, pick_index: int, round_number: int, direction: str):    await db.execute("""        UPDATE drafts        SET current_pick_index = ?, round_number = ?, direction = ?        WHERE id = ?    """, (pick_index, round_number, direction, draft_id))async def get_participant_count(db, draft_id: int) -> int:    cur = await db.execute("SELECT COUNT(*) AS cnt FROM participants WHERE draft_id = ?", (draft_id,))    row = await cur.fetchone()    return row["cnt"]async def advance_pick(db, draft_id: int):    state = await get_draft_state(db, draft_id)    if not state:        return    current, round_num, direction = state    total = await get_participant_count(db, draft_id)    if total == 0:        return    if direction == "forward":        if current < total:            new_pick = current + 1        else:            new_pick = total            direction = "backward"            round_num += 1    else:        if current > 1:            new_pick = current - 1        else:            new_pick = 1            direction = "forward"            round_num += 1    await set_draft_state(db, draft_id, new_pick, round_num, direction)async def count_conference_owners(db, draft_id: int, conference: str) -> int:    cur = await db.execute("""        SELECT COUNT(DISTINCT user_id) AS cnt        FROM assigned_teams        WHERE draft_id = ? AND conference = ?    """, (draft_id, conference))    row = await cur.fetchone()    return row["cnt"]async def is_team_already_drafted(db, draft_id: int, team_name: str) -> bool:    cur = await db.execute("""        SELECT 1        FROM assigned_teams        WHERE draft_id = ? AND team_name = ?        LIMIT 1    """, (draft_id, team_name))    row = await cur.fetchone()    return row is not Noneasync def get_user_conference(db, draft_id: int, user_id: int) -> Optional[str]:    cur = await db.execute("""        SELECT conference        FROM assigned_teams        WHERE draft_id = ? AND user_id = ? AND conference IS NOT NULL        ORDER BY id ASC        LIMIT 1    """, (draft_id, user_id))    row = await cur.fetchone()    return row["conference"] if row else None# =========================# SECTION 3 — SLASH COMMANDS# =========================@bot.eventasync def on_ready():    await init_db()    await get_db()  # ensure db connection on startup    try:        synced = await tree.sync()        logger.info(f"Synced {len(synced)} commands.")    except Exception as e:        logger.exception("Failed to sync commands: %s", e)    logger.info(f"Logged in as {bot.user} (ID: {bot.user.id})")def is_admin(interaction: discord.Interaction) -> bool:    return interaction.user.id == ADMIN_ID# ---- /start_draft ----@tree.command(name="start_draft", description="Admin: Start a new draft (resets all draft data).")async def start_draft(interaction: discord.Interaction):    if not is_admin(interaction):        return await interaction.response.send_message("Only the admin can start the draft.", ephemeral=True)    db = await get_db()    draft_id = await create_new_draft(db)    await db.commit()    await interaction.response.send_message(        f"New draft created (ID: {draft_id}).\n"        f"Next: use `/assign_preteams` to assign pre‑teams."    )# ---- /assign_preteams ----@tree.command(name="assign_preteams", description="Admin: Assign all users their pre‑assigned teams in one command.")@app_commands.describe(entries="Format: @User, Team | @User2, Team2 | ...")async def assign_preteams(interaction: discord.Interaction, entries: str):    if not is_admin(interaction):        return await interaction.response.send_message("Only the admin can assign pre‑teams.", ephemeral=True)    db = await get_db()    draft_id = await get_active_draft_id(db)    if not draft_id:        return await interaction.response.send_message("Start a draft first with `/start_draft`.", ephemeral=True)    # We can't rely on interaction.message.mentions for slash commands.    # So we parse mentions by position, but we require that the admin uses proper user mentions.    # Format: @User, Team | @User2, Team2 | ...    raw_pairs = [e.strip() for e in entries.split("|") if e.strip()]    if not raw_pairs:        return await interaction.response.send_message("No valid entries found.", ephemeral=True)    assigned: List[Tuple[int, str]] = []    seen_users = set()    seen_teams = set()    # We'll parse user ID from <@123> or <@!123> style mentions    def parse_mention(s: str) -> Optional[int]:        s = s.strip()        if s.startswith("<@") and s.endswith(">"):            inner = s[2:-1]            if inner.startswith("!"):                inner = inner[1:]            if inner.isdigit():                return int(inner)        return None    for entry in raw_pairs:        try:            user_part, team_part = entry.split(",", 1)        except ValueError:            return await interaction.response.send_message(                f"Invalid entry format: `{entry}`. Use `@User, Team`.",                ephemeral=True            )        user_id = parse_mention(user_part)        if not user_id:            return await interaction.response.send_message(                f"Could not parse user mention in `{entry}`. Use actual @mentions.",                ephemeral=True            )        team_name = team_part.strip()        if team_name not in TEAM_NAMES:            return await interaction.response.send_message(                f"Team `{team_name}` not found in teams.json.",                ephemeral=True            )        if user_id in seen_users:            return await interaction.response.send_message(                f"User <@{user_id}> appears more than once.",                ephemeral=True            )        if team_name in seen_teams:            return await interaction.response.send_message(                f"Team `{team_name}` is assigned more than once in this command.",                ephemeral=True            )        seen_users.add(user_id)        seen_teams.add(team_name)        assigned.append((user_id, team_name))    # Clear existing pre‑assigned teams for this draft    await db.execute("DELETE FROM assigned_teams WHERE draft_id = ?", (draft_id,))    for user_id, team_name in assigned:        await save_preassigned_team(db, draft_id, user_id, team_name)    await db.commit()    preview_lines = [        f"{idx+1}. <@{user_id}> → {team_name}"        for idx, (user_id, team_name) in enumerate(assigned)    ]    preview = "\n".join(preview_lines)    await interaction.response.send_message(        f"Pre‑assigned teams saved for draft {draft_id}:\n\n{preview}"    )# ---- /set_draft_order ----@tree.command(name="set_draft_order", description="Admin: Set the snake draft order by mentions.")@app_commands.describe(order="Mention users in order, e.g. @User1 @User2 @User3")async def set_draft_order(interaction: discord.Interaction, order: str):    if not is_admin(interaction):        return await interaction.response.send_message("Only the admin can set draft order.", ephemeral=True)    db = await get_db()    draft_id = await get_active_draft_id(db)    if not draft_id:        return await interaction.response.send_message("Start a draft first with `/start_draft`.", ephemeral=True)    # Parse mentions from the `order` string    # e.g. "<@123> <@456> <@789>"    tokens = order.split()    user_ids: List[int] = []    def parse_mention_token(token: str) -> Optional[int]:        token = token.strip()        if token.startswith("<@") and token.endswith(">"):            inner = token[2:-1]            if inner.startswith("!"):                inner = inner[1:]            if inner.isdigit():                return int(inner)        return None    for tok in tokens:        uid = parse_mention_token(tok)        if uid:            user_ids.append(uid)    if not user_ids:        return await interaction.response.send_message(            "No valid user mentions found in `order`.",            ephemeral=True        )    if len(user_ids) != len(set(user_ids)):        return await interaction.response.send_message(            "Duplicate users found in order. Each user must appear only once.",            ephemeral=True        )    await save_draft_order(db, draft_id, user_ids)    # reset draft state for safety    await set_draft_state(db, draft_id, 1, 1, "forward")    await db.commit()    preview_lines = [f"{idx+1}. <@{uid}>" for idx, uid in enumerate(user_ids)]    preview = "\n".join(preview_lines)    await interaction.response.send_message(        f"Draft order saved for draft {draft_id}:\n\n{preview}\n\n"        f"Next: use `/begin_draft` to start Round 1 (conference picks)."    )# ---- /begin_draft ----@tree.command(name="begin_draft", description="Admin: Begin the draft at Round 1 (conference ownership).")async def begin_draft(interaction: discord.Interaction):    if not is_admin(interaction):        return await interaction.response.send_message("Only the admin can begin the draft.", ephemeral=True)    db = await get_db()    draft_id = await get_active_draft_id(db)    if not draft_id:        return await interaction.response.send_message("No active draft found. Use `/start_draft` first.", ephemeral=True)    current_user_id = await get_current_pick_user(db, draft_id)    if not current_user_id:        return await interaction.response.send_message(            "Draft order is not set or has no participants. Use `/set_draft_order` first.",            ephemeral=True        )    await interaction.response.send_message(        f"Draft started for draft {draft_id}.\n\n"        f"**Round 1: Conference Ownership**\n"        f"Pick 1: <@{current_user_id}> is on the clock.\n\n"        f"Use `/pick_conference` to choose your conference. "        f"All conferences from the configured list are valid, max 2 owners per conference."    )# ---- /pick_conference (Round 1) ----@tree.command(name="pick_conference", description="Round 1: Pick the conference you want to own.")@app_commands.describe(conference="Name of the conference to own")async def pick_conference(interaction: discord.Interaction, conference: str):    db = await get_db()    draft_id = await get_active_draft_id(db)    if not draft_id:        return await interaction.response.send_message("No active draft.", ephemeral=True)    if conference not in CONFERENCES:        return await interaction.response.send_message(            f"`{conference}` is not a valid conference.",            ephemeral=True        )    current_user_id = await get_current_pick_user(db, draft_id)    if interaction.user.id != current_user_id:        return await interaction.response.send_message(            "It is not your pick.",            ephemeral=True        )    owners = await count_conference_owners(db, draft_id, conference)    if owners >= 2:        return await interaction.response.send_message(            f"`{conference}` already has 2 owners.",            ephemeral=True        )    # Make sure user has a pre‑assigned team    cur = await db.execute("""        SELECT id FROM assigned_teams        WHERE draft_id = ? AND user_id = ? AND conference IS NULL        ORDER BY id ASC        LIMIT 1    """, (draft_id, interaction.user.id))    row = await cur.fetchone()    if not row:        return await interaction.response.send_message(            "You do not have a pre‑assigned team set. Admin must use `/assign_preteams` first.",            ephemeral=True        )    # Assign conference to user's pre‑assigned team    await db.execute("""        UPDATE assigned_teams        SET conference = ?        WHERE id = ?    """, (conference, row["id"]))    # Advance pick (still Round 1, but snake logic works the same)    await advance_pick(db, draft_id)    await db.commit()    next_user_id = await get_current_pick_user(db, draft_id)    await interaction.response.send_message(        f"<@{interaction.user.id}> now owns **{conference}**.\n"        f"Their pre‑assigned team is now part of that conference.\n\n"        f"Next pick: <@{next_user_id}>"    )# ---- /draft_team (Round 2+) ----@tree.command(name="draft_team", description="Draft a CPU team into your owned conference (Round 2+).")@app_commands.describe(team="Team name exactly as in teams.json (school name)")async def draft_team(interaction: discord.Interaction, team: str):    db = await get_db()    draft_id = await get_active_draft_id(db)    if not draft_id:        return await interaction.response.send_message("No active draft.", ephemeral=True)    current_user_id = await get_current_pick_user(db, draft_id)    if interaction.user.id != current_user_id:        return await interaction.response.send_message(            "It is not your pick.",            ephemeral=True        )    if team not in TEAM_NAMES:        return await interaction.response.send_message(            f"Team `{team}` not found in teams.json.",            ephemeral=True        )    # Ensure user already owns a conference    user_conf = await get_user_conference(db, draft_id, interaction.user.id)    if not user_conf:        return await interaction.response.send_message(            "You must pick a conference first in Round 1 using `/pick_conference`.",            ephemeral=True        )    # Ensure team isn't already drafted    if await is_team_already_drafted(db, draft_id, team):        return await interaction.response.send_message(            f"Team `{team}` has already been drafted.",            ephemeral=True        )    # Insert drafted team    await db.execute("""        INSERT INTO assigned_teams (draft_id, user_id, team_name, conference)        VALUES (?, ?, ?, ?)    """, (draft_id, interaction.user.id, team, user_conf))    await advance_pick(db, draft_id)    await db.commit()    next_user_id = await get_current_pick_user(db, draft_id)    await interaction.response.send_message(        f"<@{interaction.user.id}> drafted **{team}** into **{user_conf}**.\n\n"        f"Next pick: <@{next_user_id}>"    )# =========================# SECTION 4 — HEALTH SERVER# =========================async def handle_health(request):    return web.Response(text="OK", status=200)async def start_health_server():    app = web.Application()    app.router.add_get("/health", handle_health)    runner = web.AppRunner(app)    await runner.setup()    site = web.TCPSite(runner, "0.0.0.0", 8080)    await site.start()    logger.info("Health server running on :8080/health")# =========================# MAIN ENTRYPOINT# =========================async def main():    await start_health_server()    async with bot:        await bot.start(BOT_TOKEN)if __name__ == "__main__":    asyncio.run(main())
